Privacy and Functionality through MPC
David Heath

As digital services become increasingly central to our economy and society, we increasingly sacrifice privacy. Today, applications maintain large repositories of sensitive user data to provide state-of-the-art service, and such applications continue to grow in number and sophistication. As this continues, privacy will become harder to protect, and issues like identity theft will spread.
Secure multiparty computation (MPC) is a subfield of cryptography that lets mutually untrusting parties work together to compute under encryption such that nothing is learned except agreed upon information: the parties’ private data is protected. MPC allows parties to securely compute any program, so in theory we need not sacrifice functionality to protect privacy.
MPC has not been widely adopted for two reasons. First, MPC is expensive. Compared to cleartext computing, MPC consumes considerable computation and communication. Second, it is difficult for non-experts to use MPC, since appropriate tooling is not available. My research addresses these two problems.
Perhaps my most important work was in co-discovering an MPC efficiency improvement called ‘Stacked Garbling’. Programs include conditional behavior: depending on the input, the program executes different instructions. Until Stacked Garbling, it was widely believed impossible to use conditional behavior to improve performance, because for security MPC cannot reveal which conditional instructions are executed. Stacked garbling breaks these community-held beliefs and significantly reduces communication needed to securely run pro- grams, making MPC far more efficient. Stacked Garbling improves only one MPC protocol (Garbled Circuits), but recently we have investigated similar techniques for different MPC protocols, and the direction is extremely promising. We have work in submission that demonstrates similar conditional improvements for GMW, another MPC protocol, and we continue to develop similar improvements. Such improvements will make MPC efficient for a wider variety of applications.
I have also worked on two strategies to make MPC more accessible:
1. The first strategy reworks MPC such that it more closely resembles standard computing. By doing so, we can reuse the substantial ecosystem surrounding everyday computing. We developed techniques to efficiently emulate a Zero Knowledge (ZK) CPU (ZK is a special case of MPC). The CPU approach is both more flexible and often exponentially more efficient than typical MPC approaches, which represent programs as simple circuits. In the future, we will support programs written in the C programming language and will generalize from ZK to MPC. A key challenge in representing a CPU is that at any moment the CPU must conditionally run any one instruction from its instruction set; our Stacked Garbling and related works will be critical in improving the performance of such CPU emulation.
2. The second strategy develops new domain-specific tooling with MPC in mind. I collaborated with Programming Language researchers to help develop λ-Symphony, a language that improves the state-of-the-art in MPC languages.
My research pushes the state-of-the-art in MPC efficiency and accessibility, and I am excited to continue helping enable wide-spread MPC adoption.
